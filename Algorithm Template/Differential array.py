"""
你有一个长为 n 的数组 a，一开始所有元素均为 0。
给定一些区间操作，其中 queries[i] = [left, right, x]，
你需要把子数组 a[left], a[left+1], ... a[right] 都加上 x。
返回所有操作执行完后的数组 a。


举例：
考虑数组 a = [1,3,3,5,8],对其中的相邻元素两两作差(右边-左边)
得到数组 [2,0,2,3],然后在开头补上 a[0],得到差分数组
d = [1,2,0,2,3]
这有什么用呢？
如果从左往右累加 d 中的元素，我们就 "还原" 了数组 a = [1,3,3,5,8]
这又有什么用呢？
现在把连续子数组 a[1],a[2],a[3] 都加上 10,得到
a' = [1,13,13,15,8],再次两两作差并在开头补上 a[0]，得到差分数组
d' = [1,12,0,2,-7]
对比 d 和 d' 你会发现，对 a 中连续子数组的操作，可以转变为对差分数组 d 中 "两个数" 的操作

对于数组 a, 定义其差分数组为
d[i] = a[0] if i == 0 else a[i] - a[i - 1]

性质 1：
    从左到右累加 d 中的元素，可以得到数组 a
性质 2：如下两个操作等价
    区间操作：把 a 的子数组 a[i],a[i+1]....,a[j] 都加上 x
    单点操作：把 d[i] 增加 x, 把 d[j + 1] 减少 x, 特别的,如果 j + 1 = n,则只需要把 d[i] 增加 x

利用性质 2，我们只需要 O(1) 的时间就可以完成数组 a 上的区间操作。最后利用性质 1 从差分数组复原出数组 a

"""


def main():
    n = 10
    q = [[0, 3, 4], [1, 7, 3], [3, 4, 2], [5, 5, 1], [7, 9, 5]]

    # 暴力求解 O(n^2)
    a = [0] * n
    for l, r, x in q:
        for i in range(l, r + 1):
            a[i] += x
    print(f"暴力方法求出数组 a:{a}")

    # O(n)
    def diff_array(q):
        diff = [0] * n  # 差分数组
        for left, right, x in q:
            diff[left] += x
            if right + 1 < n:
                diff[right + 1] -= x
        for i in range(1, n):
            diff[i] += diff[i - 1]  # 直接在差分数组上复原数组 a
        return diff

    diff = diff_array(q)
    print(f"差分方法求解数组 a:{diff}")


if __name__ == '__main__':
    main()
